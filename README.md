# âš™ï¸ Fundamentos y PrÃ¡cticas â€“ IngenierÃ­a de Software / Sistemas

Este repositorio servirÃ¡ como espacio personal para documentar, resumir y estudiar de manera autodidacta los temas esenciales de IngenierÃ­a de Software y Sistemas.  
El objetivo de este espacio es fortalecer mi formaciÃ³n integral como desarrollador de software, complementando mis habilidades tÃ©cnicas actuales con fundamentos teÃ³ricos y prÃ¡cticos propios de la ingenierÃ­a de software, los cuales no suelen abordarse en profundidad mediante la simple prÃ¡ctica de frameworks o lenguajes de programaciÃ³n.

Esta guÃ­a de estudio busca evitar lagunas de conocimiento que suelen afectar a desarrolladores que, aunque con aÃ±os de experiencia prÃ¡ctica, carecen de bases sÃ³lidas en conceptos clave de anÃ¡lisis, arquitectura, diseÃ±o, calidad, mantenimiento, gestiÃ³n de proyectos y toma de decisiones tÃ©cnicas fundamentadas.

AsÃ­, este proyecto personal me permitirÃ¡ tomar decisiones tÃ©cnicas y de negocio mejor fundamentadas, construir software de mayor calidad, mÃ¡s mantenible y escalable, y aportar verdadero valor a las empresas, productos y equipos de desarrollo con los que trabaje, sin depender de una formaciÃ³n universitaria formal o costosa en este momento.

---

### ğŸ“Œ MÃ³dulo 1: Fundamentos de IngenierÃ­a de Software

Este mÃ³dulo introduce los principios bÃ¡sicos que diferencian el desarrollo de software profesional de la simple programaciÃ³n. Comprender quÃ© es la ingenierÃ­a de software te permite construir soluciones con propÃ³sito, escalables y sostenibles, con base en procesos estructurados y buenas prÃ¡cticas.

-   Â¿QuÃ© es la IngenierÃ­a de Software?
-   Principios de calidad de software (Modularidad, AbstracciÃ³n, CohesiÃ³n, Acoplamiento).
-   Proceso de desarrollo de software (SDLC).

ğŸ“„ [Ver Resumen Completo](./01-fundamentos-ingenieria/summary.md)

ğŸ“˜ Curso Recomendado: [Fundamentos de IngenierÃ­a de Software](https://platzi.com/cursos/ingenieria/)

---

### ğŸ“Œ MÃ³dulo 2: Paradigmas de ProgramaciÃ³n

Este mÃ³dulo explora los enfoques fundamentales para estructurar y organizar software. Entender los paradigmas te permite razonar mejor sobre el diseÃ±o, elegir herramientas apropiadas y escribir cÃ³digo mÃ¡s claro, mantenible y expresivo.

-   Â¿QuÃ© es un paradigma de programaciÃ³n?
-   Paradigma imperativo (estructurado)
-   Paradigma orientado a objetos (OOP)
-   Paradigma funcional
-   Paradigma declarativo y lÃ³gico
-   Lenguajes multiparadigma (Python, JavaScript, etc.)
-   Comparativa y aplicaciones segÃºn contexto

ğŸ“„ [Ver Resumen Completo](./02-paradigmas-programacion/summary.md)

---

### ğŸ“Œ MÃ³dulo 3: Modelos de Desarrollo de Software

Los modelos de desarrollo definen cÃ³mo se organiza el trabajo dentro de un proyecto. Aprenderlos te permite adaptarte a distintos entornos laborales y metodologÃ­as, ya sean tradicionales, Ã¡giles o hÃ­bridas, comprendiendo los beneficios y limitaciones de cada enfoque.

-   Modelos predictivos: Cascada, V-Model.
-   Modelos iterativos: Prototipos, Espiral.
-   Modelos Ã¡giles: Scrum, Kanban, XP.
-   DevOps: Conceptos y flujo continuo.

ğŸ“„ [Ver Resumen Completo](./03-modelos-desarrollo/summary.md)

ğŸ“˜ Curso Recomendado: [Clase de modelos y metodologÃ­as de desarrollo de software](https://youtu.be/uhZgYsUI2A8?si=quBj61Z-4CW-hjBL)

---

### ğŸ“Œ MÃ³dulo 4: AnÃ¡lisis de Requisitos

Antes de construir cualquier software, es esencial entender quÃ© problema se quiere resolver. El anÃ¡lisis de requisitos permite obtener claridad, prevenir errores costosos y asegurar que el producto cumpla con las expectativas del usuario y los objetivos del negocio.

-   Levantamiento de requisitos.
-   Tipos: funcionales, no funcionales.
-   Modelado de requisitos (Casos de uso, Historias de Usuario).
-   UML bÃ¡sico (Diagrama de Casos de Uso).

ğŸ“„ [Ver Resumen Completo](./04-analisis-requisitos/summary.md)

---

### ğŸ“Œ MÃ³dulo 5: DiseÃ±o y Arquitectura de Software

Este mÃ³dulo se enfoca en cÃ³mo estructurar tu aplicaciÃ³n para que sea mantenible, extensible y robusta. Conocer patrones y arquitecturas te permite construir software limpio, eficiente y alineado con las necesidades tÃ©cnicas y del negocio.

-   Principios de diseÃ±o de software.
-   Patrones de DiseÃ±o (GoF): Factory, Singleton, Strategy, etc.
-   Patrones de Arquitectura: Monolito, Microservicios, Event-Driven, Serverless.
-   Modelado arquitectÃ³nico: C4 Model, Diagramas de Componentes.

ğŸ“„ [Ver Resumen Completo](./05-diseno-arquitectura/summary.md)

ğŸ“˜ Curso Recomendado: [Curso de Arquitecturas Limpias](https://platzi.com/cursos/arquitecturas-limpias/)

---

### ğŸ“Œ MÃ³dulo 6: Estructuras de Datos y Algoritmos para IngenierÃ­a

La eficiencia de un programa depende en gran parte de su estructura de datos y de los algoritmos implementados. Aunque no se usen directamente a diario en muchos frameworks, dominarlos marca la diferencia entre un programador promedio y uno capaz de optimizar soluciones reales.

-   AnÃ¡lisis de complejidad (Big O).
-   Estructuras: listas, pilas, colas, Ã¡rboles, grafos.
-   Algoritmos: bÃºsqueda, ordenamiento, recorrido de grafos.

---

### ğŸ“Œ MÃ³dulo 7: Pruebas de Software (Testing)

No basta con que el software funcione: debe ser confiable. Este mÃ³dulo aborda las pruebas como parte clave del desarrollo profesional, ayudando a prevenir errores, automatizar validaciones y mantener la calidad con el paso del tiempo.

-   Tipos: unitarias, integraciÃ³n, aceptaciÃ³n.
-   TDD: Desarrollo guiado por pruebas.
-   Herramientas: Jest, PHPUnit, etc.

ğŸ“„ [Ver Resumen Completo](./07-pruebas-software/summary.md)

---

### ğŸ“Œ MÃ³dulo 8: Mantenimiento y EvoluciÃ³n

El verdadero costo del software estÃ¡ en su mantenimiento. Entender cÃ³mo gestionar deuda tÃ©cnica, aplicar refactorizaciones y adaptar sistemas a nuevas necesidades es clave para construir productos sostenibles a largo plazo.

-   Tipos de mantenimiento.
-   Deuda tÃ©cnica y su gestiÃ³n.
-   RefactorizaciÃ³n continua.

---

### ğŸ“Œ MÃ³dulo 9: GestiÃ³n de Proyectos de Software

No importa cuÃ¡n bien programes si el proyecto no se entrega a tiempo o dentro del presupuesto. Aprender gestiÃ³n de proyectos te permite planificar, estimar y coordinar el desarrollo con enfoque profesional y orientado al resultado.

-   EstimaciÃ³n de costos y tiempos (COCOMO, Puntos de funciÃ³n).
-   GestiÃ³n Ã¡gil: Scrum, Kanban.
-   Herramientas: Jira, Trello.

---

### ğŸ“Œ MÃ³dulo 10: Calidad de Software

La calidad no es solo estÃ©tica o rendimiento. Este mÃ³dulo cubre estÃ¡ndares internacionales, mÃ©tricas y criterios que permiten evaluar y mejorar continuamente el producto, asegurando que cumpla con lo prometido.

-   EstÃ¡ndares ISO/IEC 25010.
-   Factores de calidad: fiabilidad, usabilidad, eficiencia.
-   MÃ©tricas de software.

---

### ğŸ“Œ MÃ³dulo 11: Seguridad de Software

En un mundo donde los ataques informÃ¡ticos son cada vez mÃ¡s frecuentes, la seguridad debe estar integrada en todo el ciclo de desarrollo. Aprender buenas prÃ¡cticas desde temprano reduce riesgos y fortalece tu perfil profesional.

-   Principios de seguridad.
-   OWASP Top 10.
-   PrÃ¡cticas de desarrollo seguro.

---

### ğŸ“Œ MÃ³dulo 12: Toma de Decisiones TÃ©cnicas

Un buen desarrollador no solo escribe cÃ³digo, tambiÃ©n elige tecnologÃ­as y soluciones con criterio. AquÃ­ se desarrollan habilidades para analizar trade-offs y justificar decisiones en base a contexto tÃ©cnico y de negocio.

-   EvaluaciÃ³n de trade-offs (rendimiento, costo, mantenimiento).
-   AnÃ¡lisis de impacto en negocio y producto.
-   Ejemplos: Monolito vs Microservicios, SQL vs NoSQL.

ğŸ“„ [Ver Resumen Completo](./12-toma-decisiones/summary.md)

---

### ğŸ“Œ MÃ³dulo 13: DocumentaciÃ³n TÃ©cnica y de Usuario

Un software sin documentaciÃ³n es difÃ­cil de mantener, escalar o entregar. Este mÃ³dulo cubre cÃ³mo escribir documentaciÃ³n Ãºtil tanto para otros desarrolladores como para usuarios finales, incluyendo APIs y arquitectura.

-   DocumentaciÃ³n de APIs: Swagger.
-   DocumentaciÃ³n de arquitectura: ADR, C4 Model.
-   Manuales de usuario.

---

## ğŸš§ Estado del Repositorio

En construcciÃ³n. Este repositorio se irÃ¡ completando progresivamente conforme avance en mi proceso de aprendizaje.
