# ⚙️ Fundamentos y Prácticas – Ingeniería de Software / Sistemas

Este repositorio servirá como espacio personal para documentar, resumir y estudiar de manera autodidacta los temas esenciales de Ingeniería de Software y Sistemas.  
El objetivo de este espacio es fortalecer mi formación integral como desarrollador de software, complementando mis habilidades técnicas actuales con fundamentos teóricos y prácticos propios de la ingeniería de software, los cuales no suelen abordarse en profundidad mediante la simple práctica de frameworks o lenguajes de programación.

Esta guía de estudio busca evitar lagunas de conocimiento que suelen afectar a desarrolladores que, aunque con años de experiencia práctica, carecen de bases sólidas en conceptos clave de análisis, arquitectura, diseño, calidad, mantenimiento, gestión de proyectos y toma de decisiones técnicas fundamentadas.

Así, este proyecto personal me permitirá tomar decisiones técnicas y de negocio mejor fundamentadas, construir software de mayor calidad, más mantenible y escalable, y aportar verdadero valor a las empresas, productos y equipos de desarrollo con los que trabaje, sin depender de una formación universitaria formal o costosa en este momento.

---

### 📌 Módulo 1: Fundamentos de Ingeniería de Software

Este módulo introduce los principios básicos que diferencian el desarrollo de software profesional de la simple programación. Comprender qué es la ingeniería de software te permite construir soluciones con propósito, escalables y sostenibles, con base en procesos estructurados y buenas prácticas.

🔹 ¿Qué es la Ingeniería de Software?  
🔹 Principios de calidad de software (Modularidad, Abstracción, Cohesión, Acoplamiento).  
🔹 Proceso de desarrollo de software (SDLC).  
🔹 Diferencias con programación.

---

### 📌 Módulo 2: Modelos de Desarrollo de Software

Los modelos de desarrollo definen cómo se organiza el trabajo dentro de un proyecto. Aprenderlos te permite adaptarte a distintos entornos laborales y metodologías, ya sean tradicionales, ágiles o híbridas, comprendiendo los beneficios y limitaciones de cada enfoque.

🔹 Modelos predictivos: Cascada, V-Model.  
🔹 Modelos iterativos: Prototipos, Espiral.  
🔹 Modelos ágiles: Scrum, Kanban, XP.  
🔹 DevOps: Conceptos y flujo continuo.

---

### 📌 Módulo 3: Análisis de Requisitos

Antes de construir cualquier software, es esencial entender qué problema se quiere resolver. El análisis de requisitos permite obtener claridad, prevenir errores costosos y asegurar que el producto cumpla con las expectativas del usuario y los objetivos del negocio.

🔹 Levantamiento de requisitos.  
🔹 Tipos: funcionales, no funcionales.  
🔹 Modelado de requisitos (Casos de uso, Historias de Usuario).  
🔹 UML básico (Diagrama de Casos de Uso).

📄 [Ver Resumen Completo](./03-analisis-requisitos/resumen.md)

---

### 📌 Módulo 4: Diseño y Arquitectura de Software

Este módulo se enfoca en cómo estructurar tu aplicación para que sea mantenible, extensible y robusta. Conocer patrones y arquitecturas te permite construir software limpio, eficiente y alineado con las necesidades técnicas y del negocio.

🔹 Principios SOLID.  
🔹 Patrones de Diseño (GoF): Factory, Singleton, Strategy, etc.  
🔹 Patrones de Arquitectura: Monolito, Microservicios, Event-Driven, Serverless.  
🔹 Modelado arquitectónico: C4 Model, Diagramas de Componentes.

### 📌 Módulo 5: Estructuras de Datos y Algoritmos para Ingeniería

La eficiencia de un programa depende en gran parte de su estructura de datos y de los algoritmos implementados. Aunque no se usen directamente a diario en muchos frameworks, dominarlos marca la diferencia entre un programador promedio y uno capaz de optimizar soluciones reales.

🔹 Análisis de complejidad (Big O).  
🔹 Estructuras: listas, pilas, colas, árboles, grafos.  
🔹 Algoritmos: búsqueda, ordenamiento, recorrido de grafos.

---

### 📌 Módulo 6: Pruebas de Software (Testing)

No basta con que el software funcione: debe ser confiable. Este módulo aborda las pruebas como parte clave del desarrollo profesional, ayudando a prevenir errores, automatizar validaciones y mantener la calidad con el paso del tiempo.

🔹 Tipos: unitarias, integración, aceptación.  
🔹 TDD: Desarrollo guiado por pruebas.  
🔹 Herramientas: Jest, PHPUnit, etc.

---

### 📌 Módulo 7: Mantenimiento y Evolución

El verdadero costo del software está en su mantenimiento. Entender cómo gestionar deuda técnica, aplicar refactorizaciones y adaptar sistemas a nuevas necesidades es clave para construir productos sostenibles a largo plazo.

🔹 Tipos de mantenimiento.  
🔹 Deuda técnica y su gestión.  
🔹 Refactorización continua.

---

### 📌 Módulo 8: Gestión de Proyectos de Software

No importa cuán bien programes si el proyecto no se entrega a tiempo o dentro del presupuesto. Aprender gestión de proyectos te permite planificar, estimar y coordinar el desarrollo con enfoque profesional y orientado al resultado.

🔹 Estimación de costos y tiempos (COCOMO, Puntos de función).  
🔹 Gestión ágil: Scrum, Kanban.  
🔹 Herramientas: Jira, Trello.

---

### 📌 Módulo 9: Calidad de Software

La calidad no es solo estética o rendimiento. Este módulo cubre estándares internacionales, métricas y criterios que permiten evaluar y mejorar continuamente el producto, asegurando que cumpla con lo prometido.

🔹 Estándares ISO/IEC 25010.  
🔹 Factores de calidad: fiabilidad, usabilidad, eficiencia.  
🔹 Métricas de software.

---

### 📌 Módulo 10: Seguridad de Software

En un mundo donde los ataques informáticos son cada vez más frecuentes, la seguridad debe estar integrada en todo el ciclo de desarrollo. Aprender buenas prácticas desde temprano reduce riesgos y fortalece tu perfil profesional.

🔹 Principios de seguridad.  
🔹 OWASP Top 10.  
🔹 Prácticas de desarrollo seguro.

---

### 📌 Módulo 11: Toma de Decisiones Técnicas

Un buen desarrollador no solo escribe código, también elige tecnologías y soluciones con criterio. Aquí se desarrollan habilidades para analizar trade-offs y justificar decisiones en base a contexto técnico y de negocio.

🔹 Evaluación de trade-offs (rendimiento, costo, mantenimiento).  
🔹 Análisis de impacto en negocio y producto.  
🔹 Ejemplos: Monolito vs Microservicios, SQL vs NoSQL.

---

### 📌 Módulo 12: Documentación Técnica y de Usuario

Un software sin documentación es difícil de mantener, escalar o entregar. Este módulo cubre cómo escribir documentación útil tanto para otros desarrolladores como para usuarios finales, incluyendo APIs y arquitectura.

🔹 Documentación de APIs: Swagger.  
🔹 Documentación de arquitectura: ADR, C4 Model.  
🔹 Manuales de usuario.

---

## 🚧 Estado del Repositorio

En construcción. Este repositorio se irá completando progresivamente conforme avance en mi proceso de aprendizaje.

---

## 👨‍💻 Autor

**Andrés Gutiérrez Hurtado**  
Técnico en Programación de Software | Estudiante de Tecnología en Análisis y Desarrollo de Software
